From 35bbf3b205fae1c0df589420a48bf97fff824153 Mon Sep 17 00:00:00 2001
From: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
Date: Tue, 7 Nov 2017 19:34:38 +0530
Subject: [PATCH 2/4] cxgb4: add cudbg support

Add support to collect cudbg debug logs from cxgb4.

Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
---
 drivers/net/ethernet/chelsio/cxgb4/Makefile        |   3 +-
 drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c  |  26 +-
 .../net/ethernet/chelsio/cxgb4/cudbg_flash_utils.c | 241 +++++++++++++++
 drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h      |  42 +++
 drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c     | 302 ++++++++++++-------
 drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.h     |   7 +
 .../net/ethernet/chelsio/cxgb4/cudbg_lib_common.h  |  36 ++-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c   | 126 +++++++-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h   |   1 +
 drivers/net/ethernet/chelsio/cxgb4/fastlz.c        | 328 +++++++++++++++++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz.h        |  88 ++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c    | 176 +++++++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h | 134 +++++++++
 13 files changed, 1394 insertions(+), 116 deletions(-)
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/cudbg_flash_utils.c
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz.c
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz.h
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h

diff --git a/drivers/net/ethernet/chelsio/cxgb4/Makefile b/drivers/net/ethernet/chelsio/cxgb4/Makefile
index 5414a7de..f4423026 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/Makefile
+++ b/drivers/net/ethernet/chelsio/cxgb4/Makefile
@@ -6,7 +6,8 @@ obj-$(CONFIG_CHELSIO_T4) += cxgb4.o
 
 cxgb4-objs := cxgb4_main.o l2t.o t4_hw.o sge.o clip_tbl.o cxgb4_ethtool.o \
 	      cxgb4_cudbg.o \
-	      cudbg_common.o cudbg_lib.o
+	      cudbg_common.o cudbg_lib.o \
+	      cudbg_flash_utils.o fastlz_api.o fastlz.o
 cxgb4-$(CONFIG_CHELSIO_T4_DCB) +=  cxgb4_dcb.o
 cxgb4-$(CONFIG_CHELSIO_T4_UWIRE) +=  cxgb4_ppm.o
 cxgb4-$(CONFIG_DEBUG_FS) += cxgb4_debugfs.o
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
index f78ba174..0543c35e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
@@ -18,8 +18,10 @@
 #include "cxgb4.h"
 #include "cudbg_if.h"
 #include "cudbg_lib_common.h"
+#include "fastlz_common.h"
 
-int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
+int cudbg_get_buff(struct cudbg_init *pdbg_init,
+		   struct cudbg_buffer *pdbg_buff, u32 size,
 		   struct cudbg_buffer *pin_buff)
 {
 	u32 offset;
@@ -28,17 +30,35 @@ int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
 	if (offset + size > pdbg_buff->size)
 		return CUDBG_STATUS_NO_MEM;
 
+	if (pdbg_init->compress_type != CUDBG_COMPRESSION_NONE) {
+		pin_buff->data = (char *)pdbg_init->compress_buff;
+		pin_buff->offset = 0;
+		pin_buff->size = size;
+		return 0;
+	}
+
 	pin_buff->data = (char *)pdbg_buff->data + offset;
 	pin_buff->offset = offset;
 	pin_buff->size = size;
-	pdbg_buff->size -= size;
 	return 0;
 }
 
+void cudbg_get_compress_buff(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *pdbg_buff,
+			     struct cudbg_buffer *pin_buff)
+{
+	/* There is at least CUDBG_BLOCK_SIZE extra reserved for
+	 * compression result during pdbg_init->compress_buff
+	 * allocation.  So, we can never run out of space.
+	 */
+	pin_buff->data = (char *)pdbg_init->compress_buff + pdbg_buff->size;
+	pin_buff->offset = pdbg_buff->size;
+	pin_buff->size = CUDBG_BLOCK_SIZE;
+}
+
 void cudbg_put_buff(struct cudbg_buffer *pin_buff,
 		    struct cudbg_buffer *pdbg_buff)
 {
-	pdbg_buff->size += pin_buff->size;
 	pin_buff->data = NULL;
 	pin_buff->offset = 0;
 	pin_buff->size = 0;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_flash_utils.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_flash_utils.c
new file mode 100644
index 00000000..b29b948d
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_flash_utils.c
@@ -0,0 +1,241 @@
+/*
+ *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms and conditions of the GNU General Public License,
+ *  version 2, as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  The full GNU General Public License is included in this distribution in
+ *  the file called "COPYING".
+ *
+ */
+
+#include "cxgb4.h"
+#include "t4_hw.h"
+#include "cudbg_if.h"
+#include "cudbg_lib_common.h"
+
+static int write_flash(struct adapter *adap, u32 start_sec, void *data,
+		       u32 size)
+{
+	unsigned int sf_sec_size;
+	u8 *ptr = (u8 *)data;
+	unsigned int addr;
+	unsigned int i, n;
+	int rc = 0;
+
+	sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;
+	addr =  start_sec * SF_SEC_SIZE;
+	i = DIV_ROUND_UP(size,/* # of sectors spanned */
+			 sf_sec_size);
+
+	rc = t4_flash_erase_sectors(adap, start_sec,
+				    start_sec + i - 1);
+	/* If size == 0 then we're simply erasing the FLASH sectors associated
+	 * with the on-adapter OptionROM Configuration File.
+	 */
+	if (rc || size == 0)
+		return rc;
+
+	/* this will write to the flash up to SF_PAGE_SIZE at a time */
+	for (i = 0; i < size; i += SF_PAGE_SIZE) {
+		if ((size - i) <  SF_PAGE_SIZE)
+			n = size - i;
+		else
+			n = SF_PAGE_SIZE;
+		rc = t4_write_flash(adap, addr, n, ptr, 0);
+		if (rc)
+			return rc;
+
+		addr += n;
+		ptr += n;
+	}
+
+	return 0;
+}
+
+static void set_sector_availability(struct cudbg_flash_sec_info *psec_info,
+				    int sector_nu, int avail)
+{
+	sector_nu -= FLASH_CUDBG_START_SEC;
+	if (avail)
+		set_dbg_bitmap(psec_info->sec_bitmap, sector_nu);
+	else
+		reset_dbg_bitmap(psec_info->sec_bitmap, sector_nu);
+}
+
+/* This function will return empty sector available for filling */
+static int find_empty_sec(struct cudbg_flash_sec_info *psec_info)
+{
+	int i, index, bit;
+
+	for (i = FLASH_CUDBG_START_SEC;
+	     i < FLASH_CUDBG_START_SEC + FLASH_CUDBG_NSECS;
+	     i++) {
+		index = (i - FLASH_CUDBG_START_SEC) / 8;
+		bit = (i - FLASH_CUDBG_START_SEC) % 8;
+		if (!(psec_info->sec_bitmap[index] & (1 << bit)))
+			return i;
+	}
+	return CUDBG_STATUS_FLASH_FULL;
+}
+
+/* This function will get header initially. If header is already there
+ * then it will update that header
+ */
+static void update_headers(struct cudbg_init *pdbg_init,
+			   struct cudbg_buffer *dbg_buff,
+			   u64 timestamp, u32 cur_entity_hdr_offset,
+			   u32 start_offset)
+{
+	struct cudbg_flash_sec_info *psec_info;
+	struct cudbg_entity_hdr *entity_hdr;
+	struct cudbg_flash_hdr *flash_hdr;
+	struct cudbg_hdr *cudbg_hdr;
+	u32 sec_hdr_start_addr;
+	u32 total_hdr_size;
+	u32 data_hdr_size;
+	u32 hdr_offset;
+	void *sec_hdr;
+
+	psec_info = pdbg_init->psec_info;
+	data_hdr_size = CUDBG_MAX_ENTITY * sizeof(struct cudbg_entity_hdr) +
+			sizeof(struct cudbg_hdr);
+	total_hdr_size = data_hdr_size + sizeof(struct cudbg_flash_hdr);
+	sec_hdr_start_addr = SF_SEC_SIZE - total_hdr_size;
+	sec_hdr = psec_info->sec_data + sec_hdr_start_addr;
+
+	flash_hdr = (struct cudbg_flash_hdr *)sec_hdr;
+	cudbg_hdr = (struct cudbg_hdr *)pdbg_init->outbuf;
+
+	/* initially initialize flash hdr and copy all data headers and
+	 * in next calling (else part) copy only current entity header
+	 */
+	if ((start_offset - psec_info->skip_size) == data_hdr_size) {
+		flash_hdr->signature = CUDBG_FL_SIGNATURE;
+		flash_hdr->major_ver = CUDBG_FL_MAJOR_VERSION;
+		flash_hdr->minor_ver = CUDBG_FL_MINOR_VERSION;
+		flash_hdr->build_ver = CUDBG_FL_BUILD_VERSION;
+		flash_hdr->hdr_len = sizeof(struct cudbg_flash_hdr);
+		hdr_offset =  sizeof(struct cudbg_flash_hdr);
+
+		memcpy((void *)((char *)sec_hdr + hdr_offset),
+		       (void *)((char *)dbg_buff->data), data_hdr_size);
+	} else {
+		memcpy((void *)((char *)sec_hdr +
+			sizeof(struct cudbg_flash_hdr) +
+			cur_entity_hdr_offset),
+			(void *)((char *)dbg_buff->data +
+			cur_entity_hdr_offset),
+			sizeof(struct cudbg_entity_hdr));
+	}
+
+	hdr_offset = data_hdr_size + sizeof(struct cudbg_flash_hdr);
+	flash_hdr->data_len = cudbg_hdr->data_len - psec_info->skip_size;
+	flash_hdr->timestamp = timestamp;
+
+	entity_hdr = (struct cudbg_entity_hdr *)((char *)sec_hdr +
+		      sizeof(struct cudbg_flash_hdr) +
+		      cur_entity_hdr_offset);
+	/* big entity like mc need to be skipped */
+	entity_hdr->start_offset -= psec_info->skip_size;
+
+	cudbg_hdr = (struct cudbg_hdr *)
+		    ((char *)sec_hdr + sizeof(struct cudbg_flash_hdr));
+	cudbg_hdr->data_len = flash_hdr->data_len;
+}
+
+/* Write CUDBG data into serial flash */
+int cudbg_write_flash(struct cudbg_init *pdbg_init,
+		      struct cudbg_buffer *dbg_buff,
+		      u32 start_offset, u32 cur_entity_hdr_offset,
+		      u32 cur_entity_size)
+{
+	struct cudbg_flash_hdr *flash_hdr = NULL;
+	struct cudbg_flash_sec_info *psec_info;
+	u64 timestamp = pdbg_init->time;
+	struct adapter *adap = NULL;
+	u32 sec_hdr_start_addr;
+	u32 sec_data_offset;
+	u32 total_hdr_size;
+	u32 sec_data_size;
+	u32 data_hdr_size;
+	u32 tmp_size;
+	u32 space_left;
+	int rc = 0;
+	int sec;
+
+	psec_info = pdbg_init->psec_info;
+	adap = pdbg_init->adap;
+
+	data_hdr_size = CUDBG_MAX_ENTITY * sizeof(struct cudbg_entity_hdr) +
+			sizeof(struct cudbg_hdr);
+	total_hdr_size = data_hdr_size + sizeof(struct cudbg_flash_hdr);
+	sec_hdr_start_addr = SF_SEC_SIZE - total_hdr_size;
+	sec_data_size = sec_hdr_start_addr;
+
+	dev_info(adap->pdev_dev, "\tWriting %u bytes to flash\n",
+		 cur_entity_size);
+
+	/* This function will get header if psec_info->sec_data does not
+	 * have any header and will update the header if it has header
+	 */
+
+	update_headers(pdbg_init, dbg_buff, timestamp,
+		       cur_entity_hdr_offset,
+		       start_offset);
+
+	flash_hdr = (struct cudbg_flash_hdr *)(psec_info->sec_data +
+					       sec_hdr_start_addr);
+
+	if (flash_hdr->data_len > FLASH_CUDBG_MAX_SIZE)
+		return CUDBG_STATUS_FLASH_FULL;
+
+	space_left = FLASH_CUDBG_MAX_SIZE - flash_hdr->data_len;
+	if (cur_entity_size > space_left)
+		return CUDBG_STATUS_FLASH_FULL;
+
+	while (cur_entity_size > 0) {
+		sec = find_empty_sec(psec_info);
+		if (psec_info->par_sec) {
+			sec_data_offset = psec_info->par_sec_offset;
+			set_sector_availability(psec_info, psec_info->par_sec, 0);
+			psec_info->par_sec = 0;
+			psec_info->par_sec_offset = 0;
+
+		} else {
+			psec_info->cur_seq_no++;
+			flash_hdr->sec_seq_no = psec_info->cur_seq_no;
+			sec_data_offset = 0;
+		}
+
+		if (cur_entity_size + sec_data_offset > sec_data_size) {
+			tmp_size = sec_data_size - sec_data_offset;
+		} else {
+			tmp_size = cur_entity_size;
+			psec_info->par_sec = sec;
+			psec_info->par_sec_offset = cur_entity_size +
+						    sec_data_offset;
+		}
+
+		memcpy((void *)((char *)psec_info->sec_data + sec_data_offset),
+		       (void *)((char *)dbg_buff->data + start_offset),
+		       tmp_size);
+
+		rc = write_flash(adap, sec, psec_info->sec_data,
+				 SF_SEC_SIZE);
+		if (rc)
+			return rc;
+
+		cur_entity_size -= tmp_size;
+		set_sector_availability(psec_info, sec, 1);
+		start_offset += tmp_size;
+	}
+
+	return rc;
+}
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h b/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
index e8173ae3..bc46cec4 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
@@ -20,9 +20,11 @@
 
 /* Error codes */
 #define CUDBG_STATUS_NO_MEM -19
+#define CUDBG_STATUS_OUTBUFF_OVERFLOW -20
 #define CUDBG_STATUS_ENTITY_NOT_FOUND -24
 #define CUDBG_SYSTEM_ERROR -29
 #define CUDBG_STATUS_CCLK_NOT_DEFINED -32
+#define CUDBG_STATUS_FLASH_FULL -33
 
 #define CUDBG_MAJOR_VERSION 1
 #define CUDBG_MINOR_VERSION 14
@@ -79,17 +81,57 @@ enum cudbg_dbg_entity_type {
 	CUDBG_MBOX_LOG = 66,
 	CUDBG_HMA_INDIRECT = 67,
 	CUDBG_HMA = 68,
+	CUDBG_UPLOAD = 69,
 	CUDBG_MAX_ENTITY = 70,
 };
 
+struct cudbg_flash_sec_info {
+	int par_sec;		   /* Represent partially filled sector no */
+	int par_sec_offset;	   /* Offset in partially filled sector */
+	int cur_seq_no;
+	u32 max_seq_no;
+	u32 max_seq_sec;
+	u32 hdr_data_len;	   /* Total data */
+	u32 skip_size;		   /* Total size of large entities. */
+	u64 max_timestamp;
+	char sec_data[SF_SEC_SIZE];
+	u8 sec_bitmap[8];
+};
+
 struct cudbg_init {
 	struct adapter *adap; /* Pointer to adapter structure */
 	void *outbuf; /* Output buffer */
 	u32 outbuf_size;  /* Output buffer size */
+	u8 compress_type; /* Type of compression to use */
+	bool use_flash; /* If set, debug entity is also written to flash */
+	u64 time; /* Timestamp */
+	unsigned char *hash_table; /* Hash table used for fastlz compression */
+	void *compress_buff; /* Buffer used for compression */
+	struct cudbg_flash_sec_info *psec_info; /* Flash sector information */
+};
+
+enum {
+	CUDBG_OS_TYPE_LINUX = 2,
 };
 
 static inline unsigned int cudbg_mbytes_to_bytes(unsigned int size)
 {
 	return size * 1024 * 1024;
 }
+
+static inline void set_dbg_bitmap(u8 *bitmap, enum cudbg_dbg_entity_type type)
+{
+	int index = type / 8;
+	int bit = type % 8;
+
+	bitmap[index] |= (1 << bit);
+}
+
+static inline void reset_dbg_bitmap(u8 *bitmap, enum cudbg_dbg_entity_type type)
+{
+	int index = type / 8;
+	int bit = type % 8;
+
+	bitmap[index] &= ~(1 << bit);
+}
 #endif /* __CUDBG_IF_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
index 40917ea1..2b5f339e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
@@ -23,12 +23,59 @@
 #include "cudbg_lib_common.h"
 #include "cudbg_entity.h"
 #include "cudbg_lib.h"
+#include "fastlz_common.h"
 
-static void cudbg_write_and_release_buff(struct cudbg_buffer *pin_buff,
-					 struct cudbg_buffer *dbg_buff)
+static int cudbg_do_compression(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *dbg_buff)
 {
-	cudbg_update_buff(pin_buff, dbg_buff);
+	struct cudbg_buffer temp_in_buff = { 0 };
+	int bytes_left, bytes_read, bytes;
+	u32 offset = dbg_buff->offset;
+	int rc;
+
+	temp_in_buff.offset = pin_buff->offset;
+	temp_in_buff.data = pin_buff->data;
+	temp_in_buff.size = pin_buff->size;
+
+	bytes_left = pin_buff->size;
+	bytes_read = 0;
+	while (bytes_left > 0) {
+		bytes = min_t(unsigned long, bytes_left,
+			      (unsigned long)CUDBG_CHUNK_SIZE);
+		temp_in_buff.data = (char *)pin_buff->data + bytes_read;
+		temp_in_buff.size = bytes;
+		rc = cudbg_compress_buff(pdbg_init, &temp_in_buff, dbg_buff);
+		if (rc)
+			return rc;
+		bytes_left -= bytes;
+		bytes_read += bytes;
+	}
+
+	pin_buff->size = dbg_buff->offset - offset;
+	return 0;
+}
+
+static int cudbg_write_and_release_buff(struct cudbg_init *pdbg_init,
+					struct cudbg_buffer *pin_buff,
+					struct cudbg_buffer *dbg_buff)
+{
+	int rc = 0;
+
+	if (pdbg_init->compress_type == CUDBG_COMPRESSION_NONE) {
+		cudbg_update_buff(pin_buff, dbg_buff);
+	} else {
+		rc = cudbg_write_compression_hdr(pdbg_init, pin_buff, dbg_buff);
+		if (rc)
+			goto out;
+
+		rc = cudbg_do_compression(pdbg_init, pin_buff, dbg_buff);
+		if (rc)
+			goto out;
+	}
+out:
 	cudbg_put_buff(pin_buff, dbg_buff);
+	return rc;
 }
 
 static int is_fw_attached(struct cudbg_init *pdbg_init)
@@ -357,6 +404,44 @@ int cudbg_fill_meminfo(struct adapter *padap,
 	return 0;
 }
 
+int cudbg_wr_entity_to_flash(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *dbg_buff,
+			     struct cudbg_entity_hdr *entity_hdr)
+{
+	u32 cur_entity_hdr_offset = sizeof(struct cudbg_hdr);
+	u32 cur_entity_data_offset, cur_entity_size;
+	u32 remain_flash_size, flash_data_offset;
+	struct adapter *padap = pdbg_init->adap;
+	u32 data_hdr_size;
+	int rc = -1;
+
+	cur_entity_data_offset = entity_hdr->start_offset;
+	cur_entity_size = entity_hdr->size;
+
+	data_hdr_size = CUDBG_MAX_ENTITY * sizeof(struct cudbg_entity_hdr) +
+			sizeof(struct cudbg_hdr);
+	flash_data_offset = (FLASH_CUDBG_NSECS *
+			     (sizeof(struct cudbg_flash_hdr) + data_hdr_size)) +
+			    cur_entity_data_offset - data_hdr_size;
+
+	if (flash_data_offset > FLASH_CUDBG_MAX_SIZE)
+		return -ENOMEM;
+
+	remain_flash_size = FLASH_CUDBG_MAX_SIZE - flash_data_offset;
+	if (cur_entity_size > remain_flash_size) {
+		dev_warn(padap->pdev_dev, "Large entity. Skipping");
+	} else {
+		cur_entity_hdr_offset += sizeof(struct cudbg_entity_hdr) *
+					 (entity_hdr->entity_type - 1);
+		rc = cudbg_write_flash(pdbg_init, dbg_buff, cur_entity_data_offset,
+				       cur_entity_hdr_offset, cur_entity_size);
+		if (rc == CUDBG_STATUS_FLASH_FULL)
+			dev_err(padap->pdev_dev, "\n\tFLASH is full... ");
+	}
+
+	return rc;
+}
+
 int cudbg_collect_reg_dump(struct cudbg_init *pdbg_init,
 			   struct cudbg_buffer *dbg_buff,
 			   struct cudbg_error *cudbg_err)
@@ -371,12 +456,11 @@ int cudbg_collect_reg_dump(struct cudbg_init *pdbg_init,
 	else if (is_t5(padap->params.chip) || is_t6(padap->params.chip))
 		buf_size = T5_REGMAP_SIZE;
 
-	rc = cudbg_get_buff(dbg_buff, buf_size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, buf_size, &temp_buff);
 	if (rc)
 		return rc;
 	t4_get_regs(padap, (void *)temp_buff.data, temp_buff.size);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
@@ -395,7 +479,7 @@ int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
 	}
 
 	dparams = &padap->params.devlog;
-	rc = cudbg_get_buff(dbg_buff, dparams->size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, dparams->size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -409,13 +493,12 @@ int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
 				  1);
 		spin_unlock(&padap->win0_lock);
 		if (rc) {
-			cudbg_err->sys_err = rc;
+			cudbg_err->sys_err = CUDBG_SYSTEM_ERROR;
 			cudbg_put_buff(&temp_buff, dbg_buff);
 			return rc;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
@@ -436,7 +519,7 @@ int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
 	}
 
 	size += sizeof(cfg);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -456,8 +539,7 @@ int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
@@ -469,7 +551,7 @@ int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
 	int size, rc;
 
 	size = 2 * CIM_MALA_SIZE * 5 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -477,8 +559,7 @@ int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
 			  (u32 *)temp_buff.data,
 			  (u32 *)((char *)temp_buff.data +
 				  5 * CIM_MALA_SIZE));
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
@@ -490,7 +571,7 @@ int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
 	struct cudbg_cim_qcfg *cim_qcfg_data;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_cim_qcfg),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_cim_qcfg),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -516,8 +597,7 @@ int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
 
 	t4_read_cimq_cfg(padap, cim_qcfg_data->base, cim_qcfg_data->size,
 			 cim_qcfg_data->thres);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
@@ -531,7 +611,7 @@ static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
 
 	/* collect CIM IBQ */
 	qsize = CIM_IBQ_SIZE * 4 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, qsize, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -548,8 +628,7 @@ static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_ibq_tp0(struct cudbg_init *pdbg_init,
@@ -616,7 +695,7 @@ static int cudbg_read_cim_obq(struct cudbg_init *pdbg_init,
 
 	/* collect CIM OBQ */
 	qsize =  cudbg_cim_obq_size(padap, qid);
-	rc = cudbg_get_buff(dbg_buff, qsize, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -633,8 +712,7 @@ static int cudbg_read_cim_obq(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_obq_ulp0(struct cudbg_init *pdbg_init,
@@ -887,7 +965,7 @@ static int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,
 
 		bytes = min_t(unsigned long, bytes_left,
 			      (unsigned long)CUDBG_CHUNK_SIZE);
-		rc = cudbg_get_buff(dbg_buff, bytes, &temp_buff);
+		rc = cudbg_get_buff(pdbg_init, dbg_buff, bytes, &temp_buff);
 		if (rc)
 			return rc;
 
@@ -913,7 +991,7 @@ static int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,
 skip_read:
 		bytes_left -= bytes;
 		bytes_read += bytes;
-		cudbg_write_and_release_buff(&temp_buff, dbg_buff);
+		cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 	}
 	return rc;
 }
@@ -1004,9 +1082,12 @@ int cudbg_collect_rss(struct cudbg_init *pdbg_init,
 {
 	struct adapter *padap = pdbg_init->adap;
 	struct cudbg_buffer temp_buff = { 0 };
+	unsigned int nentries;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, RSS_NENTRIES * sizeof(u16), &temp_buff);
+	nentries = t4_chip_rss_size(padap);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, nentries * sizeof(u16),
+			    &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1016,8 +1097,7 @@ int cudbg_collect_rss(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
@@ -1030,7 +1110,7 @@ int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
 	int vf, rc, vf_count;
 
 	vf_count = padap->params.arch.vfcount;
-	rc = cudbg_get_buff(dbg_buff,
+	rc = cudbg_get_buff(pdbg_init, dbg_buff,
 			    vf_count * sizeof(struct cudbg_rss_vf_conf),
 			    &temp_buff);
 	if (rc)
@@ -1040,8 +1120,7 @@ int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
 	for (vf = 0; vf < vf_count; vf++)
 		t4_read_rss_vf_config(padap, vf, &vfconf[vf].rss_vf_vfl,
 				      &vfconf[vf].rss_vf_vfh, true);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_path_mtu(struct cudbg_init *pdbg_init,
@@ -1052,13 +1131,12 @@ int cudbg_collect_path_mtu(struct cudbg_init *pdbg_init,
 	struct cudbg_buffer temp_buff = { 0 };
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, NMTUS * sizeof(u16), &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, NMTUS * sizeof(u16), &temp_buff);
 	if (rc)
 		return rc;
 
 	t4_read_mtu_tbl(padap, (u16 *)temp_buff.data, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
@@ -1070,7 +1148,7 @@ int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
 	struct cudbg_pm_stats *pm_stats_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_pm_stats),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_pm_stats),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1078,8 +1156,7 @@ int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
 	pm_stats_buff = (struct cudbg_pm_stats *)temp_buff.data;
 	t4_pmtx_get_stats(padap, pm_stats_buff->tx_cnt, pm_stats_buff->tx_cyc);
 	t4_pmrx_get_stats(padap, pm_stats_buff->rx_cnt, pm_stats_buff->rx_cyc);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
@@ -1094,7 +1171,7 @@ int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
 	if (!padap->params.vpd.cclk)
 		return CUDBG_STATUS_CCLK_NOT_DEFINED;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_hw_sched),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_hw_sched),
 			    &temp_buff);
 	hw_sched_buff = (struct cudbg_hw_sched *)temp_buff.data;
 	hw_sched_buff->map = t4_read_reg(padap, TP_TX_MOD_QUEUE_REQ_MAP_A);
@@ -1103,8 +1180,7 @@ int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
 	for (i = 0; i < NTX_SCHED; ++i)
 		t4_get_tx_sched(padap, i, &hw_sched_buff->kbps[i],
 				&hw_sched_buff->ipg[i], true);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
@@ -1128,7 +1204,7 @@ int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
 
 	n = n / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1217,8 +1293,7 @@ int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
 			       tp_pio->ireg_local_offset, true);
 		ch_tp_pio++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
@@ -1230,7 +1305,7 @@ int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
 	struct ireg_buf *ch_sge_dbg;
 	int i, rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(*ch_sge_dbg) * 2, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(*ch_sge_dbg) * 2, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1251,8 +1326,7 @@ int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
 				 sge_pio->ireg_local_offset);
 		ch_sge_dbg++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
@@ -1264,7 +1338,7 @@ int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
 	struct cudbg_ulprx_la *ulprx_la_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_ulprx_la),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_ulprx_la),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1272,8 +1346,7 @@ int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
 	ulprx_la_buff = (struct cudbg_ulprx_la *)temp_buff.data;
 	t4_ulprx_read_la(padap, (u32 *)ulprx_la_buff->data);
 	ulprx_la_buff->size = ULPRX_LA_SIZE;
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tp_la(struct cudbg_init *pdbg_init,
@@ -1286,15 +1359,14 @@ int cudbg_collect_tp_la(struct cudbg_init *pdbg_init,
 	int size, rc;
 
 	size = sizeof(struct cudbg_tp_la) + TPLA_SIZE *  sizeof(u64);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
 	tp_la_buff = (struct cudbg_tp_la *)temp_buff.data;
 	tp_la_buff->mode = DBGLAMODE_G(t4_read_reg(padap, TP_DBG_LA_CONFIG_A));
 	t4_tp_read_la(padap, (u64 *)tp_la_buff->data, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
@@ -1306,7 +1378,7 @@ int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
 	struct cudbg_meminfo *meminfo_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_meminfo), &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_meminfo), &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1318,8 +1390,7 @@ int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
 		return rc;
 	}
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
@@ -1333,7 +1404,7 @@ int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
 
 	size = sizeof(struct cudbg_cim_pif_la) +
 	       2 * CIM_PIFLA_SIZE * 6 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1342,8 +1413,7 @@ int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
 	t4_cim_read_pif_la(padap, (u32 *)cim_pif_la_buff->data,
 			   (u32 *)cim_pif_la_buff->data + 6 * CIM_PIFLA_SIZE,
 			   NULL, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
@@ -1359,7 +1429,7 @@ int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
 	if (!padap->params.vpd.cclk)
 		return CUDBG_STATUS_CCLK_NOT_DEFINED;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_clk_info),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_clk_info),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1391,8 +1461,7 @@ int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
 	clk_info_buff->finwait2_timer =
 		tp_tick_us * t4_read_reg(padap, TP_FINWAIT2_TIMER_A);
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
@@ -1407,7 +1476,7 @@ int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1448,8 +1517,7 @@ int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
 				 pcie_pio->ireg_local_offset);
 		ch_pcie++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
@@ -1464,7 +1532,7 @@ int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_pm_rx_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1505,8 +1573,7 @@ int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
 				 pm_pio->ireg_local_offset);
 		ch_pm++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tid(struct cudbg_init *pdbg_init,
@@ -1520,7 +1587,7 @@ int cudbg_collect_tid(struct cudbg_init *pdbg_init,
 	u32 para[2], val[2];
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_tid_info_region_rev1),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_tid_info_region_rev1),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1590,8 +1657,7 @@ int cudbg_collect_tid(struct cudbg_init *pdbg_init,
 
 #undef FW_PARAM_PFVF_A
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
@@ -1605,7 +1671,7 @@ int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
 
 	size = sizeof(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;
 	n = sizeof(t5_pcie_config_array) / (2 * sizeof(u32));
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1617,8 +1683,7 @@ int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
 			value++;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_sge_ctxt_check_valid(u32 *buf, int type)
@@ -1798,7 +1863,7 @@ int cudbg_collect_dump_context(struct cudbg_init *pdbg_init,
 		return CUDBG_STATUS_ENTITY_NOT_FOUND;
 
 	size = rc;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1875,8 +1940,7 @@ int cudbg_collect_dump_context(struct cudbg_init *pdbg_init,
 	 */
 	cudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, CTXT_FLM, &buff);
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static inline void cudbg_tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)
@@ -2037,7 +2101,7 @@ int cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,
 
 	n = padap->params.arch.mps_tcam_size;
 	size = sizeof(struct cudbg_mps_tcam) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2049,6 +2113,10 @@ int cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,
 			cudbg_put_buff(&temp_buff, dbg_buff);
 			return rc;
 		}
+
+		if (i && !tcam->idx)
+			continue;
+
 		total_size += sizeof(struct cudbg_mps_tcam);
 		tcam++;
 	}
@@ -2059,8 +2127,8 @@ int cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	temp_buff.size = total_size;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
@@ -2111,7 +2179,7 @@ int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
 	if (rc)
 		return rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_vpd_data),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_vpd_data),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2127,8 +2195,7 @@ int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
 	vpd_data->fw_minor = FW_HDR_FW_VER_MINOR_G(fw_vers);
 	vpd_data->fw_micro = FW_HDR_FW_VER_MICRO_G(fw_vers);
 	vpd_data->fw_build = FW_HDR_FW_VER_BUILD_G(fw_vers);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_read_tid(struct cudbg_init *pdbg_init, u32 tid,
@@ -2279,7 +2346,7 @@ int cudbg_collect_le_tcam(struct cudbg_init *pdbg_init,
 
 	size = sizeof(struct cudbg_tid_data) * tcam_region.max_tid;
 	size += sizeof(struct cudbg_tcam);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2302,8 +2369,7 @@ int cudbg_collect_le_tcam(struct cudbg_init *pdbg_init,
 		bytes += sizeof(struct cudbg_tid_data);
 	}
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cctrl(struct cudbg_init *pdbg_init,
@@ -2316,13 +2382,12 @@ int cudbg_collect_cctrl(struct cudbg_init *pdbg_init,
 	int rc;
 
 	size = sizeof(u16) * NMTUS * NCCTRL_WIN;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
 	t4_read_cong_tbl(padap, (void *)temp_buff.data);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
@@ -2340,7 +2405,7 @@ int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t6_ma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2376,8 +2441,7 @@ int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
 		}
 		ma_indr++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
@@ -2390,7 +2454,7 @@ int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
 	u32 i, j;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_ulptx_la),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_ulptx_la),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2411,8 +2475,7 @@ int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
 				t4_read_reg(padap,
 					    ULP_TX_LA_RDDATA_0_A + 0x10 * i);
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
@@ -2427,7 +2490,7 @@ int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_up_cim_reg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2455,13 +2518,13 @@ int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
 		rc = t4_cim_read(padap, up_cim_reg->ireg_local_offset,
 				 up_cim_reg->ireg_offset_range, buff);
 		if (rc) {
+			cudbg_err->sys_err = rc;
 			cudbg_put_buff(&temp_buff, dbg_buff);
 			return rc;
 		}
 		up_cim++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
@@ -2474,7 +2537,7 @@ int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
 	int i, rc;
 	u32 addr;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_pbt_tables),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_pbt_tables),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2528,8 +2591,7 @@ int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
 			return rc;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
@@ -2550,7 +2612,7 @@ int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
 	log = padap->mbox_log;
 	mbox_cmds = padap->mbox_log->size;
 	size = sizeof(struct cudbg_mbox_log) * mbox_cmds;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2573,8 +2635,7 @@ int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
 		}
 		mboxlog++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
@@ -2592,7 +2653,7 @@ int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t6_hma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2610,6 +2671,31 @@ int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
 				 hma_fli->ireg_local_offset);
 		hma_indr++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
+}
+
+int cudbg_collect_upload(struct cudbg_init *pdbg_init,
+			 struct cudbg_buffer *dbg_buff,
+			 struct cudbg_error *cudbg_err)
+{
+	struct adapter *padap = pdbg_init->adap;
+	struct cudbg_buffer temp_buff = { 0 };
+	u32 param, *value;
+	int rc;
+
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(u32), &temp_buff);
+	if (rc)
+		return rc;
+
+	value = (u32 *)temp_buff.data;
+	param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+		 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_LOAD));
+	rc = t4_query_params(padap, padap->mbox, padap->pf, 0, 1,
+			     &param, value);
+	if (rc < 0) {
+		cudbg_err->sys_err = CUDBG_SYSTEM_ERROR;
+		cudbg_put_buff(&temp_buff, dbg_buff);
+		return rc;
+	}
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.h b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.h
index eebefe7c..d728ea45 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.h
@@ -171,10 +171,17 @@ int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
 int cudbg_collect_hma_meminfo(struct cudbg_init *pdbg_init,
 			      struct cudbg_buffer *dbg_buff,
 			      struct cudbg_error *cudbg_err);
+int cudbg_collect_upload(struct cudbg_init *pdbg_init,
+			 struct cudbg_buffer *dbg_buff,
+			 struct cudbg_error *cudbg_err);
 
 struct cudbg_entity_hdr *cudbg_get_entity_hdr(void *outbuf, int i);
 void cudbg_align_debug_buffer(struct cudbg_buffer *dbg_buff,
 			      struct cudbg_entity_hdr *entity_hdr);
+int cudbg_wr_entity_to_flash(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *dbg_buff,
+			     struct cudbg_entity_hdr *entity_hdr);
+
 u32 cudbg_cim_obq_size(struct adapter *padap, int qid);
 int cudbg_dump_context_size(struct adapter *padap);
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
index 24b33f28..0b6d2303 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
@@ -19,6 +19,11 @@
 #define __CUDBG_LIB_COMMON_H__
 
 #define CUDBG_SIGNATURE 67856866 /* CUDB in ascii */
+#define CUDBG_FL_SIGNATURE 0x4355464c /* CUFL in ascii */
+
+#define CUDBG_FL_MAJOR_VERSION 1
+#define CUDBG_FL_MINOR_VERSION 1
+#define CUDBG_FL_BUILD_VERSION 0
 
 enum cudbg_dump_type {
 	CUDBG_DUMP_TYPE_MINI = 1,
@@ -75,13 +80,42 @@ struct cudbg_error {
 	int app_err;
 };
 
+struct cudbg_flash_hdr {
+	u32 signature;
+	u8 major_ver;
+	u8 minor_ver;
+	u8 build_ver;
+	u8 res;
+	u64 timestamp;
+	u64 time_res;
+	u32 hdr_len;
+	u32 data_len;
+	u32 hdr_flags;
+	u32 sec_seq_no;
+	u32 reserved[22];
+};
+
 #define CDUMP_MAX_COMP_BUF_SIZE ((64 * 1024) - 1)
 #define CUDBG_CHUNK_SIZE ((CDUMP_MAX_COMP_BUF_SIZE / 1024) * 1024)
 
-int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
+int cudbg_get_buff(struct cudbg_init *pdbg_init,
+		   struct cudbg_buffer *pdbg_buff, u32 size,
 		   struct cudbg_buffer *pin_buff);
+void cudbg_get_compress_buff(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *pdbg_buff,
+			     struct cudbg_buffer *pin_buff);
 void cudbg_put_buff(struct cudbg_buffer *pin_buff,
 		    struct cudbg_buffer *pdbg_buff);
 void cudbg_update_buff(struct cudbg_buffer *pin_buff,
 		       struct cudbg_buffer *pout_buff);
+int cudbg_write_flash(struct cudbg_init *pdbg_init,
+		      struct cudbg_buffer *dbg_buff,
+		      u32 start_offset, u32 cur_entity_hdr_offset,
+		      u32 cur_entity_size);
+int cudbg_write_compression_hdr(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *pout_buff);
+int cudbg_compress_buff(struct cudbg_init *pdbg_init,
+			struct cudbg_buffer *pin_buff,
+			struct cudbg_buffer *pout_buff);
 #endif /* __CUDBG_LIB_COMMON_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
index 41c87363..2d7c61f2 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
@@ -18,6 +18,7 @@
 #include "t4_regs.h"
 #include "cxgb4.h"
 #include "cxgb4_cudbg.h"
+#include "fastlz_common.h"
 
 static const struct cxgb4_collect_entity cxgb4_collect_mem_dump[] = {
 	{ CUDBG_EDC0, cudbg_collect_edc0_meminfo },
@@ -74,6 +75,23 @@ static const struct cxgb4_collect_entity cxgb4_collect_hw_dump[] = {
 	{ CUDBG_UP_CIM_INDIRECT, cudbg_collect_up_cim_indirect },
 	{ CUDBG_PBT_TABLE, cudbg_collect_pbt_tables },
 	{ CUDBG_HMA_INDIRECT, cudbg_collect_hma_indirect },
+	{ CUDBG_UPLOAD, cudbg_collect_upload },
+};
+
+static const char * cxgb4_entity_string[] = {
+	"all", "regdump", "devlog", "cimla", "cimmala", "cimqcfg",
+	"ibqtp0", "ibqtp1", "ibqulp", "ibqsge0", "ibqsge1", "ibqncsi",
+	"obqulp0", "obqulp1", "obqulp2", "obqulp3", "obqsge", "obqncsi",
+	"edc0", "edc1", "mc0", "mc1", "rss", "rss_pf_config", "rss_key",
+	"rss_vf_config", "rss_config", "pathmtu", "swstate", "wtp", "pmstats",
+	"hwsched", "tcpstats", "tperrstats", "fcoestats", "rdmastats",
+	"tpindirect", "sgeindirect", "cplstats", "ddpstats", "wcstats",
+	"ulprxla", "lbstats", "tpla", "meminfo", "cimpifla", "clk",
+	"obq_sge_rx_q0", "obq_sge_rx_q1", "macstats", "pcieindirect",
+	"pmindirect", "full", "txrate", "tidinfo", "pcieconfig",
+	"dumpcontext", "mpstcam", "vpddata", "letcam", "cctrl", "maindirect",
+	"ulptxla", "extentity", "upcimindirect", "pbttables",
+	"mboxlog", "hmaindirect", "hma", "upload",
 };
 
 static u32 cxgb4_get_entity_length(struct adapter *adap, u32 entity)
@@ -179,7 +197,7 @@ static u32 cxgb4_get_entity_length(struct adapter *adap, u32 entity)
 		len = cudbg_mbytes_to_bytes(len);
 		break;
 	case CUDBG_RSS:
-		len = RSS_NENTRIES * sizeof(u16);
+		len = t4_chip_rss_size(adap) * sizeof(u16);
 		break;
 	case CUDBG_RSS_VF_CONF:
 		len = adap->params.arch.vfcount *
@@ -301,6 +319,9 @@ static u32 cxgb4_get_entity_length(struct adapter *adap, u32 entity)
 		}
 		len = cudbg_mbytes_to_bytes(len);
 		break;
+	case CUDBG_UPLOAD:
+		len = sizeof(u32);
+		break;
 	default:
 		break;
 	}
@@ -338,23 +359,30 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 	struct adapter *adap = pdbg_init->adap;
 	struct cudbg_error cudbg_err = { 0 };
 	struct cudbg_entity_hdr *entity_hdr;
+	struct cudbg_hdr *cudbg_hdr;
 	u32 entity_size, i;
 	u32 total_size = 0;
 	int ret;
 
+	cudbg_hdr = pdbg_init->outbuf;
 	for (i = 0; i < arr_size; i++) {
 		const struct cxgb4_collect_entity *e = &e_arr[i];
 
 		/* Skip entities that won't fit in output buffer */
 		entity_size = cxgb4_get_entity_length(adap, e->entity);
 		if (entity_size >
-		    pdbg_init->outbuf_size - *tot_size - total_size)
+		    pdbg_init->outbuf_size - *tot_size - total_size) {
+			dev_warn(adap->pdev_dev, "No space for entity %s, Skipping",
+				 cxgb4_entity_string[e->entity]);
 			continue;
+		}
 
 		entity_hdr = cudbg_get_entity_hdr(buf, e->entity);
 		entity_hdr->entity_type = e->entity;
 		entity_hdr->start_offset = dbg_buff->offset;
 		memset(&cudbg_err, 0, sizeof(struct cudbg_error));
+		dev_info(adap->pdev_dev, "Collecting debug entity %s",
+			 cxgb4_entity_string[e->entity]);
 		ret = e->collect_cb(pdbg_init, dbg_buff, &cudbg_err);
 		if (ret) {
 			entity_hdr->size = 0;
@@ -363,6 +391,9 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 			cudbg_align_debug_buffer(dbg_buff, entity_hdr);
 		}
 
+		if (ret)
+			dev_warn(adap->pdev_dev, "status: %d", ret);
+
 		/* Log error and continue with next entity */
 		if (cudbg_err.sys_err)
 			ret = CUDBG_SYSTEM_ERROR;
@@ -371,6 +402,16 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 		entity_hdr->sys_err = cudbg_err.sys_err;
 		entity_hdr->sys_warn = cudbg_err.sys_warn;
 		total_size += entity_hdr->size;
+		cudbg_hdr->data_len += entity_hdr->size;
+
+		if (!ret) {
+			if (pdbg_init->use_flash)
+				cudbg_wr_entity_to_flash(pdbg_init, dbg_buff,
+							 entity_hdr);
+			else
+				dev_info(adap->pdev_dev, "size: %u",
+					 entity_hdr->size);
+		}
 	}
 
 	*tot_size += total_size;
@@ -403,6 +444,7 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 	cudbg_hdr->chip_ver = adap->params.chip;
 	cudbg_hdr->dump_type = CUDBG_DUMP_TYPE_MINI;
 	cudbg_hdr->compress_type = CUDBG_COMPRESSION_NONE;
+	cudbg_init.compress_type = CUDBG_COMPRESSION_NONE;
 
 	min_size = sizeof(struct cudbg_hdr) +
 		   sizeof(struct cudbg_entity_hdr) *
@@ -412,6 +454,7 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 
 	dbg_buff.offset += min_size;
 	total_size = dbg_buff.offset;
+	cudbg_hdr->data_len = total_size;
 
 	if (flag & CXGB4_ETH_DUMP_HW)
 		cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
@@ -427,7 +470,6 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 					   buf,
 					   &total_size);
 
-	cudbg_hdr->data_len = total_size;
 	*buf_size = total_size;
 	return 0;
 }
@@ -438,3 +480,81 @@ void cxgb4_init_ethtool_dump(struct adapter *adapter)
 	adapter->eth_dump.version = adapter->params.fw_vers;
 	adapter->eth_dump.len = 0;
 }
+
+int cxgb4_cudbg_collect_panic(struct adapter *adap, void *buf, u32 buf_size)
+{
+	struct cudbg_init cudbg_init = { 0 };
+	struct cudbg_buffer dbg_buff = { 0 };
+	u32 size, min_size, total_size = 0;
+	struct cudbg_hdr *cudbg_hdr;
+	struct timespec ts;
+
+	size = buf_size;
+
+	cudbg_init.adap = adap;
+	cudbg_init.outbuf = buf;
+	cudbg_init.outbuf_size = size;
+	cudbg_init.use_flash = true;
+	getnstimeofday(&ts);
+	cudbg_init.time = ts.tv_sec;
+	cudbg_init.hash_table = t4_alloc_mem(sizeof(unsigned char *) *
+					     FASTLZ_HASH_SIZE);
+	if (!cudbg_init.hash_table)
+		return -ENOMEM;
+
+	/* Give extra CUDBG_BLOCK_SIZE for storing compression result */
+	cudbg_init.compress_buff = t4_alloc_mem(size + CUDBG_BLOCK_SIZE);
+	if (!cudbg_init.compress_buff)
+		goto free_mem;
+
+	cudbg_init.psec_info =
+		t4_alloc_mem(sizeof(struct cudbg_flash_sec_info));
+	if (!cudbg_init.psec_info)
+		goto free_mem;
+
+	dbg_buff.data = buf;
+	dbg_buff.size = size;
+	dbg_buff.offset = 0;
+
+	cudbg_hdr = (struct cudbg_hdr *)buf;
+	cudbg_hdr->signature = CUDBG_SIGNATURE;
+	cudbg_hdr->hdr_len = sizeof(struct cudbg_hdr);
+	cudbg_hdr->major_ver = CUDBG_MAJOR_VERSION;
+	cudbg_hdr->minor_ver = CUDBG_MINOR_VERSION;
+	cudbg_hdr->max_entities = CUDBG_MAX_ENTITY;
+	cudbg_hdr->chip_ver = adap->params.chip;
+
+	min_size = sizeof(struct cudbg_hdr) +
+		   sizeof(struct cudbg_entity_hdr) *
+		   cudbg_hdr->max_entities;
+	if (size < min_size) {
+		dev_info(adap->pdev_dev, "FAIL - Min buf size: %u required\n",
+			 min_size);
+		goto free_mem;
+	}
+
+	dbg_buff.offset += min_size;
+	total_size = dbg_buff.offset;
+	cudbg_hdr->data_len = total_size;
+
+	cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
+				   cxgb4_collect_hw_dump,
+				   ARRAY_SIZE(cxgb4_collect_hw_dump),
+				   buf,
+				   &total_size);
+
+	cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
+				   cxgb4_collect_mem_dump,
+				   ARRAY_SIZE(cxgb4_collect_mem_dump),
+				   buf,
+				   &total_size);
+
+free_mem:
+	if (cudbg_init.psec_info)
+		t4_free_mem(cudbg_init.psec_info);
+	if (cudbg_init.compress_buff)
+		t4_free_mem(cudbg_init.compress_buff);
+	if (cudbg_init.hash_table)
+		t4_free_mem(cudbg_init.hash_table);
+	return 0;
+}
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
index 7ceeb0bc..caa487c8 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
@@ -41,5 +41,6 @@ enum CXGB4_ETHTOOL_DUMP_FLAGS {
 u32 cxgb4_get_dump_length(struct adapter *adap, u32 flag);
 int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 			u32 flag);
+int cxgb4_cudbg_collect_panic(struct adapter *adap, void *buf, u32 buf_size);
 void cxgb4_init_ethtool_dump(struct adapter *adapter);
 #endif /* __CXGB4_CUDBG_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz.c b/drivers/net/ethernet/chelsio/cxgb4/fastlz.c
new file mode 100644
index 00000000..331d1ff1
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz.c
@@ -0,0 +1,328 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#include "fastlz_common.h"
+
+#if !defined(FASTLZ_COMPRESSOR)
+
+#undef FASTLZ_LEVEL
+#define FASTLZ_LEVEL 1
+
+#undef FASTLZ_COMPRESSOR
+#define FASTLZ_COMPRESSOR fastlz1_compress
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output);
+#include "fastlz.c"
+
+#undef FASTLZ_LEVEL
+#define FASTLZ_LEVEL 2
+
+#undef MAX_DISTANCE
+#define MAX_DISTANCE 8191
+#define MAX_FARDISTANCE (65535 + MAX_DISTANCE - 1)
+
+#undef FASTLZ_COMPRESSOR
+#define FASTLZ_COMPRESSOR fastlz2_compress
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output);
+#include "fastlz.c"
+
+int fastlz_compress(unsigned char *hash_table, const void *input, int length,
+		    void *output)
+{
+	/* for short block, choose fastlz1 */
+	if (length < 65536)
+		return fastlz1_compress(hash_table, input, length, output);
+
+	/* else... */
+	return fastlz2_compress(hash_table, input, length, output);
+}
+
+int fastlz_compress_level(unsigned char *hash_table, int level,
+			  const void *input, int length,
+			  void *output)
+{
+	if (level == 1)
+		return fastlz1_compress(hash_table, input, length, output);
+	if (level == 2)
+		return fastlz2_compress(hash_table, input, length, output);
+
+	return 0;
+}
+
+#else /* !defined(FASTLZ_COMPRESSOR) */
+
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output)
+{
+	const unsigned char *ip = (const unsigned char *) input;
+	const unsigned char *ip_bound = ip + length - 2;
+	const unsigned char *ip_limit = ip + length - 12;
+	unsigned char *op = (unsigned char *) output;
+
+	const unsigned char **htab = (const unsigned char **)hash_table;
+	const unsigned char **hslot;
+	unsigned int hval;
+
+	unsigned int copy;
+
+	/* sanity check */
+	if (FASTLZ_UNEXPECT_CONDITIONAL(length < 4)) {
+		if (length) {
+			/* create literal copy only */
+			*op++ = length - 1;
+			ip_bound++;
+			while (ip <= ip_bound)
+				*op++ = *ip++;
+			return length + 1;
+		} else
+			return 0;
+	}
+
+	/* initializes hash table */
+	for (hslot = htab; hslot < htab + FASTLZ_HASH_SIZE; hslot++)
+		*hslot = ip;
+
+	/* we start with literal copy */
+	copy = 2;
+	*op++ = MAX_COPY - 1;
+	*op++ = *ip++;
+	*op++ = *ip++;
+
+	/* main loop */
+	while (FASTLZ_EXPECT_CONDITIONAL(ip < ip_limit)) {
+		const unsigned char *ref;
+		unsigned int distance;
+
+		/* minimum match length */
+		unsigned int len = 3;
+
+		/* comparison starting-point */
+		const unsigned char *anchor = ip;
+
+		/* check for a run */
+#if FASTLZ_LEVEL == 2
+		if (ip[0] == ip[-1] &&
+		    FASTLZ_READU16(ip - 1) == FASTLZ_READU16(ip + 1)) {
+			distance = 1;
+			ip += 3;
+			ref = anchor - 1 + 3;
+			goto match;
+		}
+#endif
+
+		/* find potential match */
+		HASH_FUNCTION(hval, ip);
+		hslot = htab + hval;
+		ref = htab[hval];
+
+		/* calculate distance to the match */
+		distance = anchor - ref;
+
+		/* update hash table */
+		*hslot = anchor;
+
+		if (!ref)
+			goto literal;
+		/* is this a match? check the first 3 bytes */
+		if (distance == 0 ||
+#if FASTLZ_LEVEL == 1
+				(distance >= MAX_DISTANCE) ||
+#else
+				(distance >= MAX_FARDISTANCE) ||
+#endif
+				*ref++ != *ip++ || *ref++ != *ip++ ||
+				*ref++ != *ip++)
+			goto literal;
+
+#if FASTLZ_LEVEL == 2
+		/* far, needs at least 5-byte match */
+		if (distance >= MAX_DISTANCE) {
+			if (*ip++ != *ref++ || *ip++ != *ref++)
+				goto literal;
+			len += 2;
+		}
+
+match:
+#endif
+
+		/* last matched byte */
+		ip = anchor + len;
+
+		/* distance is biased */
+		distance--;
+
+		if (!distance) {
+			/* zero distance means a run */
+			unsigned char x = ip[-1];
+			while (ip < ip_bound)
+				if (*ref++ != x)
+					break;
+				else
+					ip++;
+		} else
+			for (;;) {
+				/* safe because the outer check
+				 * against ip limit */
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				while (ip < ip_bound)
+					if (*ref++ != *ip++)
+						break;
+				break;
+			}
+
+		/* if we have copied something, adjust the copy count */
+		if (copy)
+			/* copy is biased, '0' means 1 byte copy */
+			*(op - copy - 1) = copy - 1;
+		else
+			/* back, to overwrite the copy count */
+			op--;
+
+		/* reset literal counter */
+		copy = 0;
+
+		/* length is biased, '1' means a match of 3 bytes */
+		ip -= 3;
+		len = ip - anchor;
+
+		/* encode the match */
+#if FASTLZ_LEVEL == 2
+		if (distance < MAX_DISTANCE) {
+			if (len < 7) {
+				*op++ = (len << 5) + (distance >> 8);
+				*op++ = (distance & 255);
+			} else {
+				*op++ = (7 << 5) + (distance >> 8);
+				for (len -= 7; len >= 255; len -= 255)
+					*op++ = 255;
+				*op++ = len;
+				*op++ = (distance & 255);
+			}
+		} else {
+			/* far away, but not yet in the another galaxy... */
+			if (len < 7) {
+				distance -= MAX_DISTANCE;
+				*op++ = (len << 5) + 31;
+				*op++ = 255;
+				*op++ = distance >> 8;
+				*op++ = distance & 255;
+			} else {
+				distance -= MAX_DISTANCE;
+				*op++ = (7 << 5) + 31;
+				for (len -= 7; len >= 255; len -= 255)
+					*op++ = 255;
+				*op++ = len;
+				*op++ = 255;
+				*op++ = distance >> 8;
+				*op++ = distance & 255;
+			}
+		}
+#else
+
+		if (FASTLZ_UNEXPECT_CONDITIONAL(len > MAX_LEN - 2))
+			while (len > MAX_LEN - 2) {
+				*op++ = (7 << 5) + (distance >> 8);
+				*op++ = MAX_LEN - 2 - 7 - 2;
+				*op++ = (distance & 255);
+				len -= MAX_LEN - 2;
+			}
+
+		if (len < 7) {
+			*op++ = (len << 5) + (distance >> 8);
+			*op++ = (distance & 255);
+		} else {
+			*op++ = (7 << 5) + (distance >> 8);
+			*op++ = len - 7;
+			*op++ = (distance & 255);
+		}
+#endif
+
+		/* update the hash at match boundary */
+		HASH_FUNCTION(hval, ip);
+		htab[hval] = ip++;
+		HASH_FUNCTION(hval, ip);
+		htab[hval] = ip++;
+
+		/* assuming literal copy */
+		*op++ = MAX_COPY - 1;
+
+		continue;
+
+literal:
+		*op++ = *anchor++;
+		ip = anchor;
+		copy++;
+		if (FASTLZ_UNEXPECT_CONDITIONAL(copy == MAX_COPY)) {
+			copy = 0;
+			*op++ = MAX_COPY - 1;
+		}
+	}
+
+	/* left-over as literal copy */
+	ip_bound++;
+	while (ip <= ip_bound) {
+		*op++ = *ip++;
+		copy++;
+		if (copy == MAX_COPY) {
+			copy = 0;
+			*op++ = MAX_COPY - 1;
+		}
+	}
+
+	/* if we have copied something, adjust the copy length */
+	if (copy)
+		*(op - copy - 1) = copy - 1;
+	else
+		op--;
+
+#if FASTLZ_LEVEL == 2
+	/* marker for fastlz2 */
+	*(unsigned char *)output |= (1 << 5);
+#endif
+
+	return op - (unsigned char *)output;
+}
+#endif /* !defined(FASTLZ_COMPRESSOR) */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz.h b/drivers/net/ethernet/chelsio/cxgb4/fastlz.h
new file mode 100644
index 00000000..c3db989b
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz.h
@@ -0,0 +1,88 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#ifndef FASTLZ_H
+#define FASTLZ_H
+
+#define FASTLZ_VERSION 0x000100
+
+#define FASTLZ_VERSION_MAJOR	 0
+#define FASTLZ_VERSION_MINOR	 0
+#define FASTLZ_VERSION_REVISION  0
+
+#define FASTLZ_VERSION_STRING "0.1.0"
+
+#if defined __cplusplus
+extern "C" {
+#endif
+
+	/**
+	  Compress a block of data in the input buffer and returns the size of
+	  compressed block. The size of input buffer is specified by length. The
+	  minimum input buffer size is 16.
+
+	  The output buffer must be at least 5% larger than the input buffer
+	  and can not be smaller than 66 bytes.
+
+	  If the input is not compressible, the return value might be larger
+	  than length (input buffer size).
+
+	  The input buffer and the output buffer can not overlap.
+	  */
+
+	int fastlz_compress(unsigned char *hash_table, const void *input,
+			    int length, void *output);
+	/**
+	  Compress a block of data in the input buffer and returns the size of
+	  compressed block. The size of input buffer is specified by length. The
+	  minimum input buffer size is 16.
+
+	  The output buffer must be at least 5% larger than the input buffer
+	  and can not be smaller than 66 bytes.
+
+	  If the input is not compressible, the return value might be larger
+	  than length (input buffer size).
+
+	  The input buffer and the output buffer can not overlap.
+
+	  Compression level can be specified in parameter level. At the moment,
+	  only level 1 and level 2 are supported.
+	  Level 1 is the fastest compression and generally useful for short
+	  data.
+	  Level 2 is slightly slower but it gives better compression ratio.
+
+	  Note that the compressed data, regardless of the level, can always be
+	  decompressed using the function fastlz_decompress above.
+	  */
+
+	int fastlz_compress_level(unsigned char *hash_table, int level,
+				  const void *input, int length,
+				  void *output);
+#if defined __cplusplus
+}
+#endif
+#endif /* FASTLZ_H */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c b/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
new file mode 100644
index 00000000..dbf78f7f
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
@@ -0,0 +1,176 @@
+/*
+ *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms and conditions of the GNU General Public License,
+ *  version 2, as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  The full GNU General Public License is included in this distribution in
+ *  the file called "COPYING".
+ *
+ */
+
+#include "cxgb4.h"
+#include "fastlz.h"
+#include "fastlz_common.h"
+#include "cudbg_if.h"
+#include "cudbg_lib_common.h"
+
+unsigned char sixpack_magic[8] = {137, '6', 'P', 'K', 13, 10, 26, 10};
+
+static int write_to_buf(void *out_buf, u32 out_buf_size, u32 *offset,
+			void *in_buf, u32 in_buf_size)
+{
+	memcpy(((char *)out_buf) + *offset, in_buf, in_buf_size);
+	*offset = *offset + in_buf_size;
+	return 0;
+}
+
+static int write_magic(struct cudbg_buffer *_out_buff)
+{
+	return write_to_buf(_out_buff->data, _out_buff->size,
+			    &_out_buff->offset, sixpack_magic, 8);
+}
+
+static int write_chunk_header(struct cudbg_buffer *_outbuf, int id, int options,
+			      unsigned long size, unsigned long checksum,
+			      unsigned long extra)
+{
+	unsigned char buffer[CUDBG_CHUNK_BUF_LEN];
+
+	buffer[0] = id & 255;
+	buffer[1] = (unsigned char)(id >> 8);
+	buffer[2] = options & 255;
+	buffer[3] = (unsigned char)(options >> 8);
+	buffer[4] = size & 255;
+	buffer[5] = (size >> 8) & 255;
+	buffer[6] = (size >> 16) & 255;
+	buffer[7] = (size >> 24) & 255;
+	buffer[8] = checksum & 255;
+	buffer[9] = (checksum >> 8) & 255;
+	buffer[10] = (checksum >> 16) & 255;
+	buffer[11] = (checksum >> 24) & 255;
+	buffer[12] = extra & 255;
+	buffer[13] = (extra >> 8) & 255;
+	buffer[14] = (extra >> 16) & 255;
+	buffer[15] = (extra >> 24) & 255;
+
+	return write_to_buf(_outbuf->data, _outbuf->size, &_outbuf->offset,
+			    buffer, 16);
+}
+
+int cudbg_write_compression_hdr(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *pout_buff)
+{
+	struct cudbg_buffer temp_buff = { 0 };
+	unsigned long fsize = pin_buff->size;
+	char *shown_name = "abc";
+	unsigned long checksum;
+	unsigned char *buffer;
+	int rc;
+
+	cudbg_get_compress_buff(pdbg_init, pin_buff, &temp_buff);
+	buffer = (unsigned char *)temp_buff.data;
+
+	rc = write_magic(pout_buff);
+	if (rc)
+		return rc;
+
+	/* chunk for File Entry */
+	buffer[0] = fsize & 255;
+	buffer[1] = (fsize >> 8) & 255;
+	buffer[2] = (fsize >> 16) & 255;
+	buffer[3] = (fsize >> 24) & 255;
+	buffer[4] = 0;
+	buffer[5] = 0;
+	buffer[6] = 0;
+	buffer[7] = 0;
+	buffer[8] = (strlen(shown_name) + 1) & 255;
+	buffer[9] = (unsigned char)((strlen(shown_name) + 1) >> 8);
+	checksum = 1L;
+	checksum = update_adler32(checksum, buffer, 10);
+	checksum = update_adler32(checksum, shown_name,
+				  (int)strlen(shown_name) + 1);
+
+	rc = write_chunk_header(pout_buff, 1, 0,
+				10 + (unsigned long)strlen(shown_name)+ 1,
+				checksum, 0);
+	if (rc)
+		return rc;
+
+	rc = write_to_buf(pout_buff->data, pout_buff->size,
+			  &pout_buff->offset, buffer, 10);
+	if (rc)
+		return rc;
+
+	rc = write_to_buf(pout_buff->data, pout_buff->size,
+			   &pout_buff->offset, shown_name,
+			   (u32)strlen(shown_name) + 1);
+	if (rc)
+		return rc;
+
+	return rc;
+}
+
+int cudbg_compress_buff(struct cudbg_init *pdbg_init,
+			struct cudbg_buffer *pin_buff,
+			struct cudbg_buffer *pout_buff)
+{
+	struct cudbg_buffer temp_buff = { 0 };
+	int chunk_size, level = 2, rc = 0;
+	int compress_method = 1;
+	unsigned int bytes_read;
+	unsigned long checksum;
+	unsigned char *result;
+
+	cudbg_get_compress_buff(pdbg_init, pin_buff, &temp_buff);
+	result = (unsigned char *)temp_buff.data;
+
+	bytes_read = pin_buff->size;
+	if (bytes_read < 32)
+		compress_method = 0;
+
+	switch (compress_method) {
+	case 1:
+		chunk_size = fastlz_compress_level(pdbg_init->hash_table,
+						   level,
+						   pin_buff->data,
+						   bytes_read, result);
+		checksum = update_adler32(1L, result, chunk_size);
+		rc = write_chunk_header(pout_buff, 17, 1, chunk_size, checksum,
+					bytes_read);
+		if (rc)
+			return rc;
+
+		rc = write_to_buf(pout_buff->data, pout_buff->size,
+				  &pout_buff->offset, result, chunk_size);
+		if (rc)
+			return rc;
+		break;
+
+		/* uncompressed, also fallback method */
+	case 0:
+	default:
+		memcpy(result, pin_buff->data, bytes_read);
+		checksum = update_adler32(1L, result, bytes_read);
+		rc = write_chunk_header(pout_buff, 17, 0, bytes_read, checksum,
+					bytes_read);
+		if (rc)
+			return rc;
+
+		rc = write_to_buf(pout_buff->data, pout_buff->size,
+				  &pout_buff->offset, result,
+				  bytes_read);
+		if (rc)
+			return rc;
+		break;
+	}
+
+	return rc;
+}
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h b/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h
new file mode 100644
index 00000000..19e0e45a
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h
@@ -0,0 +1,134 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#ifndef __FASTLZ_COMMON_H__
+#define __FASTLZ_COMMON_H__
+
+#define FASTLZ_HASH_LOG  13
+#define FASTLZ_HASH_SIZE (1 << FASTLZ_HASH_LOG)
+#define FASTLZ_HASH_MASK  (FASTLZ_HASH_SIZE - 1)
+
+/*
+ * Always check for bound when decompressing.
+ * Generally it is best to leave it defined.
+ */
+#define FASTLZ_SAFE
+
+/*
+ * Give hints to the compiler for branch prediction optimization.
+ */
+#define FASTLZ_EXPECT_CONDITIONAL(c)	(__builtin_expect((c), 1))
+#define FASTLZ_UNEXPECT_CONDITIONAL(c)	(__builtin_expect((c), 0))
+
+/*
+ * Use inlined functions for supported systems.
+ */
+#define FASTLZ_INLINE inline
+
+/*
+ * Prevent accessing more than 8-bit at once, except on x86 architectures.
+ */
+#if !defined(FASTLZ_STRICT_ALIGN)
+#define FASTLZ_STRICT_ALIGN
+#if defined(__i386__) || defined(__386)  /* GNU C, Sun Studio */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__i486__) || defined(__i586__) || defined(__i686__) /* GNU C */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(_M_IX86) /* Intel, MSVC */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__386)
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(_X86_) /* MinGW */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__I86__) /* Digital Mars */
+#undef FASTLZ_STRICT_ALIGN
+#endif
+#endif
+
+/*
+ * FIXME: use preprocessor magic to set this on different platforms!
+ */
+
+#define MAX_COPY       32
+#define MAX_LEN       264  /* 256 + 8 */
+#define MAX_DISTANCE 8192
+
+#if !defined(FASTLZ_STRICT_ALIGN)
+#define FASTLZ_READU16(p) (*((const unsigned short *)(p)))
+#else
+#define FASTLZ_READU16(p) ((p)[0] | (p)[1]<<8)
+#endif
+
+#define HASH_FUNCTION(v, p) {\
+				v = FASTLZ_READU16(p);\
+				v ^= FASTLZ_READU16(p + 1)^\
+				     (v>>(16 - FASTLZ_HASH_LOG));\
+				v &= FASTLZ_HASH_MASK;\
+			    }
+
+extern unsigned char sixpack_magic[8];
+
+#define CUDBG_BLOCK_SIZE      (63*1024)
+#define CUDBG_CHUNK_BUF_LEN   16
+#define CUDBG_MIN_COMPR_LEN   32	/*min data length for applying compression*/
+
+/* for Adler-32 checksum algorithm, see RFC 1950 Section 8.2 */
+
+#define ADLER32_BASE 65521
+
+static inline unsigned long update_adler32(unsigned long checksum,
+					   const void *buf, int len)
+{
+	const unsigned char *ptr = (const unsigned char *)buf;
+	unsigned long s1 = checksum & 0xffff;
+	unsigned long s2 = (checksum >> 16) & 0xffff;
+
+	while (len > 0) {
+		unsigned k = len < 5552 ? len : 5552;
+		len -= k;
+
+		while (k >= 8) {
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			k -= 8;
+		}
+
+		while (k-- > 0) {
+			s1 += *ptr++; s2 += s1;
+		}
+		s1 = s1 % ADLER32_BASE;
+		s2 = s2 % ADLER32_BASE;
+	}
+	return (s2 << 16) + s1;
+}
+#endif /* __FASTLZ_COMMON_H__ */
-- 
2.14.1

